#!/usr/local/bin/node

//////////////////////////////////////////////////////////////////////
//         App option defaults
//////////////////////////////////////////////////////////////////////

var 

    defaultTitle = 'Demos',

    defaultHeading = 'Demos',


//////////////////////////////////////////////////////////////////////

    http = require('http'),
    child_process = require('child_process'),
    dns = require('dns'),
    url = require('url'),
    path = require('path'),
    fs = require('fs'),
    util = require('util'),
    ws = require('ws').Server,
    httpPort = 8080,
    // We use a separate port for the web sockets
    // so that the code has less chance of braking.
    wsPort = 8888,
    heading = '',
    remote = '',
    title = '',
    signal = [],
    exitOnLast = false,
    killChildren = false,

//////////////////////////////////////////////////////////////////////
//         Supporting Files
//////////////////////////////////////////////////////////////////////

    // User configuration/setting dir
    userDir = process.env.HOME + '/.gar_demorunner',

    // Files in etc/ used to compose pages served
    serverFiles = {
        'head.htm': '', // Top of the page.
        'foot.htm': ''  // Bottom of the page.
    },

    // Filename of Demo Runner Scripts to link.
    runnerScriptFilenames = [
        'run'
    ],

    // Filename of Demo Description Files
    ///////////////////////////////////////
    
    // For HTML fragment.  If found will not use
    // txtDescFilename
    htmDescFilename = 'description.htm',

    // For simple text
    txtDescFilename = 'description.txt',

    // For small images we match this regrex
    imgIconFilename = /^demoIcon.*\.(png|jpg|JPG)/,

    // For large (Preview) images we match this regrex
    imgPreviewFilename = /^demoPreview.*\.(png|jpg|JPG)$/,


//////////////////////////////////////////////////////////////////////

    scriptDir = path.dirname(fs.realpathSync(__filename)),
    cwdOrg = process.cwd(),
    filenames = [],
    etcDir = '',
    defaultPage = '';


function usage() {
    var prog = path.basename(__filename);

    // Heredoc should be part of javascript!

    console.log(
"   Usage: " + prog + " [DOC_ROOT] [--title TITLE] [--remote ADDRESS]" +
"[--heading HEADING] [--exit-on-last] [--kill-children]\n" +
"\n" +
"  Run a " + prog + " HTTP server and WebSocket server.\n" +
"\n" +
"  The default DOC_ROOT is the current working directory.\n" +
"\n" +
"                  OPTIONS\n" +
"\n" +
"     --exit-on-last       have server exit after last connection closes\n" +
"     --heading HEADING    set <h1> page heading text to HEADING\n" +
"                          the default HEADING is \"" + defaultHeading + "\n" +
"     --kill-children      kill all launched children on exiting the server\n" +
"     --remote ADDRESS     accept connections only from address ADDRESS\n" +
"     --signal SIG PID     signal the process with PID with signal SIG just after the\n" +
"                          listening sockets are open.  Example:  --signal SIGUSR1 2354 \n" +
"     --title TITLE        set the page title text to TITLE\n" +
"                          the default title is \"" + defaultTitle + "\n" +
"\n"
    );
    process.exit(1);
}

var tagCount = 0;
var launcherFooter =
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n\n";

function addDemosFromDirectoryToDefaultPage(dir, relDir) {
    
    for(var i=0; i<runnerScriptFilenames.length; ++i)
    {
        var scriptPath = path.join(dir, runnerScriptFilenames[i]);
        var scriptURI = path.join(relDir, runnerScriptFilenames[i]);

        try {
            var stats = fs.lstatSync(scriptPath);
        }
        catch (e) {
            stats = false;
        }
        if(!stats) continue;

        console.log('found demo script path=' + scriptPath);


        // We have script.

        defaultPage += "<div class=box>\n" +
"  <span class=state>Not run yet.</span>\n" +
"  <div class=head>\n" +
"    <div onclick=\"launch(this)\" id=" + tagCount++ +
" class=launch title='run: " +
    scriptURI + "'\n" +
"      data-run='" + scriptURI + "'>\n";
            
        var f = path.join(dir, htmDescFilename);
        var text;
        try {
            // TODO: fix relative URLs in this test
            text = fs.readFileSync(f).toString();
            defaultPage += text + launcherFooter;
            // We have enough HTML for the launcher
            break;
        }
        catch (e) {
            text = false;
        }

        var images = [];
    
        try {
            // Find any images and add <img> tags to launcher <div>
            var filenames = fs.readdirSync(dir);
        }
        catch(err) {
            console.log('fs.readdirSync("' + dir + '") failed: ' + err);
            process.exit(1);
        }
        for(var i=0; i<filenames.length; ++i) {
            //console.log('checking img filename=' + filenames[i]);
            if(imgIconFilename.test(filenames[i])) {
                console.log('found img filename=' + filenames[i]);
                images.push(path.join(relDir, filenames[i]));
            }
        }

        f = path.join(dir, txtDescFilename);
        try {
            text = '';
            // Put images at the top with given text
            for(var i=0; i<images.length; ++i)
                text += "      <img class=icon src='" + images + "'>\n";
            text +=
                "      <p>\n" +
                fs.readFileSync(f).toString().replace(/\n\n/g,
                "\n" +
                "      </p>\n" +
                "      <p>\n") +
                "      </p>\n";
        }
        catch (e) {
            text = false;
        }

        if(!text) {
            text = '';
            // Put images at the top but with generic text
            for(var i=0; i<images.length; ++i)
                text += "      <img class=icon src='" + images[i] + "'>\n";
            text +=
                "      <p class=genericprog>Run " + scriptURI +
                "      <\p>\n" +
                "      <p class=genericdesc>You can add a description to this " +
                "program by creating the\n" +
                "      plain text file " +  path.join(dir, txtDescFilename) + "\n" +
                "      or the HTML fragment file " + path.join(dir, htmDescFilename) +
                "\n    </p>\n";
        }

        defaultPage += text + launcherFooter;
        // We how have a script to launch for this directory
        break;
    }
    
    // Now find directories in this directory
    try {
        var dirs = fs.readdirSync(dir);
    }
    catch(e) {
        // not able to open as a directory
        dirs = [];
    }
    for(var i=0; i<dirs.length;++i)
        addDemosFromDirectoryToDefaultPage(
                path.join(dir, dirs[i]),
                path.join(relDir, dirs[i]));
}
    
function escapeHTML(s) { 
    return s.replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/@/g, '');
}

function config() {

    for(var i=2; i < process.argv.length; ++i) {
        var str = process.argv[i];
        // TODO: rewrite this switch mess!!!!
        switch(str) {
            case '-h':
            case '--h':
            case '-help':
            case '--help':
                usage();
                break;
            case '-heading':
            case '--heading':
                if(++i < process.argv.length)
                    heading = process.argv[i];
                else
                    usage();
                break;
            case '-remote':
            case '--remote':
                if(++i < process.argv.length)
                    remote = process.argv[i];
                else
                    usage();
                break;
            case '-signal':
            case '--signal':
                if(++i < process.argv.length)
                    signal[0] = process.argv[i];
                else
                    usage();
                if(++i < process.argv.length)
                    signal[1] = process.argv[i];
                else
                    usage();
                break;
            case '-title':
            case '--title':
                if(++i < process.argv.length)
                    title = process.argv[i];
                else
                    usage();
                break;
            case '--exit-on-last':
            case '-exit-on-last':
                exitOnLast = true;
                break;
            case '--kill-children':
            case '-kill-children':
                killChildren = true;
                break;
            default:
                if(/^-(-|)heading=/.test( process.argv[i])) {
                    heading = process.argv[i].replace(/^-(-|)heading=/,'');
                    break;
                }
                if(/^-(-|)remote=/.test( process.argv[i])) {
                    remote = process.argv[i].replace(/^-(-|)remote=/,'');
                    break;
                }
                if(/^-(-|)title=/.test( process.argv[i])) {
                    title = process.argv[i].replace(/^-(-|)title=/,'');
                    break;
                }
                if(str.match(/^-/))
                    usage();
                try {
                    process.chdir(str);
                }
                catch(err) {
                    console.log('Cannot cd to ' + str + "\n\n");
                    usage();
                }
                break;
        }
    };

    if(title.length < 1) {
        if(heading.length >= 1)
            title =  heading;
        else
            title = defaultTitle;
    }
    if(heading.length < 1) {
        if(title.length >= 1)
            heading = title;
        else
            heading = defaultHeading;
    }
    heading = escapeHTML(heading);
    title = escapeHTML(title);

    var etcDirs = [ scriptDir + '/../etc' , scriptDir + '/etc' ];
    var filenames = Object.keys(serverFiles);


    // Find etcDir with is the directory where files
    // that this service needs are located.
    for(var i = 0; i < etcDirs.length; ++i) {
        // This is total bullshit, i.e. it should be one line.
        etcDir = etcDirs[i];
        headFile = path.join(etcDir, serverFiles[filenames[i]]);
        try {
                fs.accessSync(headFile, fs.R_OK)
        }
        catch(err) {
            etcDir = '';
        }
        if(etcDir != '') break;
    }
    if(etcDir == '') {
        console.log(
            'Cannot find supporting files in directories: ' +
            etcDirs + "\n\n");
        usage();
    }

    for(var i=0; i < filenames.length; ++i)
    {
        try {
            serverFiles[filenames[i]] =
                fs.readFileSync(path.join(etcDir, filenames[i]));
        }
        catch(err) {
            console.log("Error: " + err + "\n\n");
            usage();
        }
    }
    var d = false;
    try {
        d = fs.statSync(userDir);
    } catch(err) {
            fs.mkdirSync(userDir, (err, userDir) => {
                if(err)
                {
                    console.log("Failed to make directory: " +
                        userDir + "\n" + err + "\n\n");
                    process.exit(1);   
                }
        });
        console.log("Made directory: " + userDir);
    } 
    if(d && !d.isDirectory()) {
        console.log(userDir + " is not a directory.\n");
        process.exit(1);
    }

    defaultPage = serverFiles['head.htm'].toString().
        replace('@HEADING@', heading).
        replace('@TITLE@', title) +
        "\n<!-- This was a generated file.\n  END head.htm -->\n\n";

    // recurse through directories in the demos directory
    var dir = process.cwd();

    addDemosFromDirectoryToDefaultPage(dir, '/');

    defaultPage += "\n<!-- BEGIN foot.htm -->\n" +
        serverFiles['foot.htm'];

    if(remote.length > 0) {
        /*
        dns.lookup(remote, (err, address, family) => {
            if(err) {
                console.log('dns.lookup("' + remote + '") err: ' + err);
                process.exit(1);
            }
            remote = address;
        });
        console.log('remote address is restricted to: ' + remote);
        */
        dns.resolve4(remote, (err, caddress) => {   
            if(err) {
                console.log('dns.resolveCname(["' + remote + '"]) err: ' + err);
                process.exit(1);
            }
            remote = caddress;
        });
        console.log('remote (cononical) address is restricted to: ' + remote);
    } //else
        // Unrestricted  remote = ''

    // Report
    console.log('Document root is ' + process.cwd());
    console.log('HTTP server Port is ' + httpPort);
    console.log('WebSocket Port is ' + wsPort);
}



config();


function spewObject(obj, pre) {
    console.log(pre + '= ' + JSON.stringify(obj));
}

var children = {},
    socketCount = 0;

var wss = new ws({port: 8888});

function handleMessageLaunch(socket, obj)
{
    console.log('Got JSON message: {' +
            'type: "' + obj.type +
            ', state: "' + obj.state +
            '", pid: "' + obj.pid +
            '", id: "' + obj.id + '"}');

    if(obj.state == 'kill' && children[ obj.pid ]) {
        var child = children[ obj.pid ];
        try {
            console.log('will kill pid ' + child.pid);
            // child close event will delete it from children{}
            child.kill('SIGINT');
            child.kill('SIGTERM');
            //process.kill(obj.pid, 'SIGINT');
        }
        catch(err) {
            console.log('signaling ' + child.pid + ' failed');
        }
    } else if(obj.state == 'running' && children[ obj.pid ]) {
        if(children[ obj.pid ]) {
            // Create new child object
            children[ obj.pid ].Socket = socket;
            socket.Children[ obj.pid ] = children[ obj.pid ];
            // we have state for example: 
            //    { state: 'running', pid: '1234', id: '5' }
            children[ obj.pid ].State = obj;
        } else {
            // The process is no longer running
            obj.state = 'kill';
            // Tell the browser that the process is no longer
            // running and to go to launch mode for this demo.
            socket.send(JSON.stringify(obj));
        }
    } else {
         console.log('ERROR: Got bad WebSocket message state: ' + obj.state);
    }
}

function exit() {
   
    if(killChildren)
        for(var key in children) {
            var child = children[key];
            // child close event will delete it from children{}
            child.kill('SIGINT');
            child.kill('SIGTERM');
        }

    console.log("Server Exiting")
    process.exit();
}



wss.on('connection', function(socket) {

    ++socketCount;
    socket.Children = {};


    if(remote.length > 0 &&
        socket._socket.remoteAddress != remote) {
            console.log('revoking WebSocket connection (' +
                socketCount + ") address=" + socket._socket.remoteAddress);
            socket.close();
            return;
    }
    console.log('got WebSocket connection (' +
        socketCount + ") address=" + socket._socket.remoteAddress);

    socket.on('message', function(message) {
 
        console.log('WebSocket received: ' + message);

        var obj = JSON.parse(message);

        if(obj.type == 'launch')
            handleMessageLaunch(this, obj);
        else if(obj.type == 'quit')
            exit();
    });

    socket.on('close', function() {
        --socketCount;
        console.log('Web Socket ' + socket._socket.remoteAddress + ' closed');

        if(socketCount == 0 && exitOnLast) {

            setTimeout(function() {
                // We exit is no connection came to be in the timeout.
                // This makes a browser page reload possible.
                if(socketCount < 1) {
                    console.log('no more Web Socket connections: exiting');
                    exit();
                }
            }, 3000 /* milli-seconds */);
        }
    });
});



function httpRequest(request, response) {

    function getContentType(file) {

        var suffix = {
            "text/plain": /\.txt$/,
            "image/png": /\.png$/,
            "image/jpeg": /\.(jpg|JPG|jpeg|JPEG)$/,
            "text/html": /\.html$/,
        };
        for (var type in suffix) {
            if(suffix[type].test(file))
                return type;
        }
        return "text/plain";
    }

    console.log('accepted connection from address:  ' + request.connection.remoteAddress);

    var parse =  url.parse(request.url);

    console.log("parse.path=" + parse.path);
    console.log("parse.query=" + parse.query);

    var fpath = path.join(process.cwd(), parse.pathname);

    try {
        var stats = fs.lstatSync(fpath);
    }
    catch (e) {
        stats = false;
    }



    if(stats && parse.query == 'run') {
        /////////////////////////////////////
        //////////// Run fpath //////////////
        /////////////////////////////////////
        console.log('server running: ' + fpath);
        //////////// async version //////////
        try {
            var child = child_process.spawn(fpath, 
                {
                    cwd: path.dirname(fpath),
                    detached: false,
                    stdio: [0,1,2]
                }
            );
        }
        catch(err) {

            console.log('Failed to start child process: ' + err);
            
            response.writeHead(200, {"Content-Type": "text/plain"});
            response.write(JSON.stringify({ state: 'failed', pid: '0' }));
            response.end();
            child = false;
        }

        if(child)
        {
            console.log('         ' +
                    fpath + " is running  child.pid=", child.pid);

            children[ child.pid.toString() ] = child;
            
            response.writeHead(200, {"Content-Type": "text/plain"});
            response.write(JSON.stringify( { state: 'running',
                                    pid: child.pid.toString() }));
            response.end();

            child.on('close', (code) => {
                if (code !== 0) {
                    console.log(fpath +
                            ' exited with status code=' +
                            code);
                }
                var pid = child.pid.toString();

                console.log('child with pid=' + pid + ' exited');
                console.log('children[' + pid + ']=' + children[pid]);
                if(children[ pid ]) {
                    var socket = children[ pid ].Socket;
                    var state = children[ pid ].State;
                    if(socket)
                    {
                        state.state = 'dead';
                        try {
                            console.log('sending: ' + JSON.stringify(state));
                            socket.send(JSON.stringify(state));
                            delete socket.Children[ pid ];
                        } catch(e){
                            /* The socket may have been closed already */
                        }
                    }
                    delete children[ pid ];
                }
            });

        }
    } else if(parse.query == 'etc') {
        /////////////////////////////////////
        ////////// Files from etc/   ////////
        /////////////////////////////////////
        fpath = path.join(etcDir, parse.pathname);

        fs.readFile(fpath, "binary", function(err, file) {
            if(err) {
                response.writeHead(500, {"Content-Type": "text/plain"});
                response.write("err=" +  err + "\n");
                response.end();
                console.log(fpath + ' not found ' + err);
            } else {

                // TODO: find the file mime type from the filename
                // to fix this writeHead():

                response.writeHead(200, { 'Content-Type': getContentType(fpath) });
                response.write(file, "binary");
                response.end();
                console.log('sent file: ' + fpath);
            }
        });

    } else if(stats && stats.isDirectory()) {
        /////////////////////////////////////
        ////////// Send default page ////////
        /////////////////////////////////////
        response.writeHead(200, { 'Content-Type': 'text/html' });
        response.write(defaultPage, "binary");
        response.end();
    } else if(stats) {
        /////////////////////////////////////
        //////////// Sent a file ////////////
        /////////////////////////////////////
        fs.readFile(fpath, "binary", function(err, file) {
            if(err) {        
                response.writeHead(500, {"Content-Type": "text/plain"});
                response.write("err=" +  err + "\n");
                response.end();
                console.log(fpath + ' not found ' + err);
            } else {
                response.writeHead(200, { 'Content-Type': getContentType(fpath) });
                response.write(file, "binary");
                response.end();
                console.log('sent file: ' + fpath);
            }
        });
    } else {
        /////////////////////////////////////
        /////////// file not found //////////
        /////////////////////////////////////
        response.writeHead(404, {"Content-Type": "text/plain"});
        response.write("404 Not Found\n");
        response.end();
    }
}

var didLookup = false;


var server = http.createServer(function(request, response) {

    if(remote.length > 0) {
        // Restrict access to this server.
        // TODO: The address has a prefix like ::ffff:  I don't know why.

        var raddress = request.connection.remoteAddress.replace(/^.*:/, '');
        if(raddress  != remote) {

            // First try a DNS lookup to see if this is the same address.

            if(! didLookup) {
                didLookup = true;
                dns.resolve(raddress , (err, address) => {   
                    if(err) {
                        console.log('dns.resolve("' +
                            raddress  + '") err: ' + err);
                        process.exit(1);
                    }
                    if(remote == address) {
                        remote = request.connection.remoteAddress;
                        httpRequest(request, response);
                    } else {
                        console.log('rejected connection from address:  ' + raddress );
                        response.end();
                        return;
                    }
                });
                return;
            }
            console.log('rejected connection from address:  ' + raddress );
            response.end();
            return;
        }
    }
    
    httpRequest(request, response);

}).listen(httpPort);


// TODO: Hostname happens to be a value domain name, but this is not
// good for the general server URL.
console.log("demoRunner service at  => http://" + require('os').hostname() + ":" + httpPort);

if(signal.length >= 1)
{
    try {
    process.kill(signal[1], signal[0]);
    } catch (err) {
        console.log('signaling ' );
    }
}

